# Malware-Konzepte - Demonstrationsbeispiele

## ⚠️ WICHTIGER HINWEIS
Diese Beispiele dienen **ausschließlich zu Bildungszwecken** und zur Demonstration von Sicherheitskonzepten. Die hier gezeigten Techniken sollten **niemals** für schädliche Zwecke oder ohne ausdrückliche Erlaubnis eingesetzt werden. Die Verwendung dieser Techniken auf Systemen, die Sie nicht besitzen oder für die Sie keine Autorisierung haben, ist illegal.

## Übersicht

Dieses Repository enthält drei Python-Skripte, die verschiedene Malware-Verschleierungstechniken demonstrieren:

1. **verschlüsselt.py** - Einfache Code-Verschlüsselung
2. **polymorph.py** - Polymorphe Malware
3. **metamorph.py** - Metamorphe Malware

---

## 1. verschlüsselt.py - Einfache Verschlüsselung

### Konzept
Dies ist die einfachste Form der Code-Verschleierung. Der eigentliche Payload ist mit dem Fernet-Verschlüsselungsverfahren verschlüsselt und wird erst zur Laufzeit entschlüsselt und ausgeführt.

### Funktionsweise
```
┌─────────────────┐
│ Verschlüsselter │
│     Payload     │
└────────┬────────┘
         │
         ▼
    Entschlüsselung
         │
         ▼
     exec(code)
```

### Eigenschaften
- **Statischer Schlüssel**: Der Verschlüsselungsschlüssel ist fest im Code eingebettet
- **Statischer Payload**: Der verschlüsselte Code ändert sich nicht
- **Einfache Erkennung**: Signaturbasierte Erkennung ist möglich, da der Code bei jeder Ausführung identisch ist

### Sicherheitsaspekt
Diese Technik verhindert nur die statische Code-Analyse. Antivirus-Software kann:
- Die Verschlüsselungsroutine als Signatur erkennen
- Das Verhalten während der Laufzeit analysieren
- Den Entschlüsselungsprozess im Speicher überwachen

---

## 2. polymorph.py - Polymorphe Malware

### Konzept
Polymorphe Malware verändert sich bei jeder Ausführung, behält aber die gleiche grundlegende Struktur. Der Payload wird mit einem **neuen Schlüssel** bei jeder Ausführung neu verschlüsselt.

### Funktionsweise
```
Ausführung N:
┌─────────────┐     ┌──────────────┐
│  Schlüssel  │────▶│ Entschlüsseln│
│     (N)     │     │   Payload    │
└─────────────┘     └──────┬───────┘
                           │
                           ▼
                      exec(code)
                           │
                           ▼
┌─────────────┐     ┌──────────────┐
│Neuer Schlüssel────│ Verschlüsseln│
│   (N+1)     │◀────│   Payload    │
└─────────────┘     └──────────────┘
```

### Selbstmodifikation
Nach jeder Ausführung:
1. Generierung eines neuen Fernet-Schlüssels
2. Verschlüsselung des Payloads mit dem neuen Schlüssel
3. Überschreibung der eigenen Datei mit:
   - Neuem Schlüssel
   - Neu verschlüsseltem Payload

### Eigenschaften
- **Dynamischer Schlüssel**: Bei jeder Ausführung wird ein neuer Verschlüsselungsschlüssel generiert
- **Veränderlicher Datei-Hash**: Der SHA-256 Hash der Datei ändert sich bei jeder Ausführung
- **Gleicher Payload**: Der entschlüsselte Code bleibt funktional identisch

### Sicherheitsaspekt
Diese Technik erschwert die Erkennung erheblich:
- Signaturbasierte Erkennung schlägt fehl (ändernder Hash)
- Verhaltensbasierte Analyse ist notwendig
- Die Entschlüsselungsroutine selbst bleibt konstant (Schwachstelle)

---

## 3. metamorph.py - Metamorphe Malware

### Konzept
Metamorphe Malware ist die fortschrittlichste Form der Code-Verschleierung. Sie verändert nicht nur die Verschlüsselung, sondern auch die **Struktur des Codes selbst**, während die Funktionalität erhalten bleibt.

### Funktionsweise
```
Ausführung N:
┌─────────────┐     ┌──────────────┐
│  Schlüssel  │────▶│ Entschlüsseln│
│     (N)     │     │   Payload    │
└─────────────┘     └──────┬───────┘
                           │
                           ▼
                   ┌───────────────┐
                   │ add_dummies() │ ◀─── Fügt nutzlose Funktionen hinzu
                   └───────┬───────┘
                           │
                           ▼
                   ┌───────────────┐
                   │randomize_vars()│ ◀─── Benennt Variablen um
                   └───────┬───────┘
                           │
                           ▼
                      exec(code)
                           │
                           ▼
                   ┌───────────────┐
                   │Neuer Schlüssel│
                   │Neuer Code     │
                   │Selbst-Update  │
                   └───────────────┘
```

### Metamorphose-Techniken

#### 1. Dummy-Code-Insertion
Fügt zufällige, funktionslose Code-Abschnitte hinzu:
- Dummy-Funktionen mit unterschiedlichen Operationen
- Zufällige Variablen mit zufälligen Werten
- Bei jeder Ausführung werden 2-4 zufällige Dummies gewählt

**Beispiel:**
```python
# Generation 1:
def abcdefgh(): return sum([1,2,3])
def ijklmnop(): x = 42; return x * 2

# Generation 2:
def qrstuvwx(): s = 'data'; return len(s)
def yzabcdef(): return sum([1,2,3])
ghijklmn = 73
```

#### 2. Variablen-Randomisierung
Alle Variablennamen werden durch zufällige 8-Zeichen-Strings ersetzt:
- Regex-basierte Erkennung von Bezeichnern
- Schutz von Python-Keywords
- Konsistentes Mapping innerhalb einer Generation

**Beispiel:**
```python
# Original:
counter = 0
for item in range(10):
    counter += item

# Nach Randomisierung:
abcdefgh = 0
for ijklmnop in range(10):
    abcdefgh += ijklmnop
```

#### 3. Selbstmodifikation
- Neuer Verschlüsselungsschlüssel
- Verschlüsselung des **modifizierten** Codes
- Regex-basierte Aktualisierung der Quelldatei

### Eigenschaften
- **Strukturelle Metamorphose**: Code-Struktur ändert sich bei jeder Ausführung
- **Funktionale Äquivalenz**: Das Verhalten bleibt identisch
- **Maximale Verschleierung**: Kombiniert Verschlüsselung, Obfuskation und Metamorphose
- **Dynamische Signatur**: Keine zwei Generationen sind gleich

### Sicherheitsaspekt
Dies ist die schwierigste Form zu erkennen:
- Signaturbasierte Erkennung ist nahezu unmöglich
- Code-Struktur ist bei jeder Ausführung unterschiedlich
- Erfordert fortgeschrittene heuristische Analyse
- Die Metamorphose-Engine selbst bleibt ein Erkennungspunkt

---

## Vergleichstabelle

| Eigenschaft | verschlüsselt.py | polymorph.py | metamorph.py |
|-------------|------------------|--------------|--------------|
| **Verschlüsselung** | ✅ Statisch | ✅ Dynamisch | ✅ Dynamisch |
| **Schlüsseländerung** | ❌ Nein | ✅ Ja | ✅ Ja |
| **Code-Struktur** | Statisch | Statisch | ✅ Dynamisch |
| **Dummy-Code** | ❌ Nein | ❌ Nein | ✅ Ja |
| **Variablen-Randomisierung** | ❌ Nein | ❌ Nein | ✅ Ja |
| **Selbstmodifikation** | ❌ Nein | ✅ Ja | ✅ Ja |
| **Erkennungsschwierigkeit** | Niedrig | Mittel | Hoch |
| **Datei-Hash ändert sich** | ❌ Nein | ✅ Ja | ✅ Ja |

---

## Technische Details

### Abhängigkeiten
```bash
pip install cryptography
```

### Verwendete Technologien
- **Fernet-Verschlüsselung**: Symmetrische Verschlüsselung (AES-128 im CBC-Modus)
- **Regex**: Für Pattern-Matching und Code-Manipulation
- **exec()**: Dynamische Code-Ausführung
- **Datei-I/O**: Selbstmodifikation durch Überschreiben

### Dateisignatur-Analyse
Sie können die Veränderung der Dateien mit folgendem Befehl nachvollziehen:

```bash
# Windows PowerShell
Get-FileHash polymorph.py -Algorithm SHA256
# Führe das Skript aus
python polymorph.py
# Hash erneut prüfen - er wird unterschiedlich sein
Get-FileHash polymorph.py -Algorithm SHA256
```

---

## Erkennung und Gegenmaßnahmen

### Erkennungsmethoden
1. **Statische Analyse**
   - Suche nach Fernet-Import und exec()-Aufrufen
   - Erkennung von Selbstmodifikations-Mustern
   
2. **Verhaltensanalyse**
   - Überwachung von Datei-Selbstmodifikation
   - Analyse von exec()-Aufrufen mit verschlüsselten Daten
   
3. **Heuristische Erkennung**
   - Entropie-Analyse (verschlüsselte Strings haben hohe Entropie)
   - Code-Muster-Erkennung

### Schutzmaßnahmen
- **Application Whitelisting**: Nur vertrauenswürdige Programme ausführen
- **Verhaltensbasierte Antivirus-Lösungen**: Erkennung verdächtiger Verhaltensmuster
- **Sandbox-Analyse**: Ausführung in isolierter Umgebung zur Verhaltensbeobachtung
- **Code-Signing**: Nur signierte Skripte ausführen

---

## Bildungszweck und Ethik

### Warum diese Beispiele existieren
Diese Demonstrationen helfen zu verstehen:
- Wie Malware Erkennungsmechanismen umgeht
- Warum mehrschichtige Sicherheit notwendig ist
- Wie moderne Bedrohungen funktionieren
- Warum verhaltensbasierte Erkennung wichtig ist

### Verantwortungsvolle Nutzung
- ✅ Verwenden Sie diese für Sicherheitsforschung
- ✅ Testen Sie nur auf eigenen Systemen
- ✅ Verstehen Sie die Gegenmaßnahmen
- ❌ Verwenden Sie diese nicht für schädliche Zwecke
- ❌ Verbreiten Sie diese nicht als Malware
- ❌ Testen Sie nicht auf fremden Systemen

---

## Literatur und Weiterführendes

### Empfohlene Ressourcen
- **MITRE ATT&CK Framework**: Taktiken und Techniken von Angreifern
- **Malware Analysis Bootcamp**: Praktische Malware-Analyse
- **The Art of Computer Virus Research and Defense**: Klassisches Werk zu Malware

### Verwandte Konzepte
- **Code Obfuscation**: Weitere Verschleierungstechniken
- **Packing**: Komprimierung und Verschlüsselung von Executables
- **Anti-Debugging**: Techniken zur Verhinderung von Analyse
- **Sandboxing**: Sichere Ausführungsumgebungen

---

## Lizenz und Haftungsausschluss

**HAFTUNGSAUSSCHLUSS**: Der Autor übernimmt keine Verantwortung für den Missbrauch dieser Beispiele. Diese Software wird "wie sie ist" bereitgestellt, ohne jegliche ausdrückliche oder stillschweigende Gewährleistung.

Verwenden Sie diese Beispiele auf eigene Verantwortung und nur für legale und ethische Zwecke.

---

*Erstellt zu Bildungszwecken - 2025*
